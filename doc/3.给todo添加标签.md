给todo添加时间了，好像还不足以分类，如果此时能加个标签就好多了。于是乎加吧。
但是加标签意味着得处理标签与todo的关联关系了：

1. 一个todo可以添加多个标签

2. 多个todo可能同时含有同一个标签

3. 同时输入标签时最好可以有自动完成

如果是关系型数据库，这些都不是啥事情，直接来一个多对多的关系，可惜`indexDB`是一种`nosql`
数据库，并没有关联关系。

那这怎么办呢，找了半天发现有个`pouchDB.js`挺符合要求，其中还有一个
关联关系的插件`relational-pouch`，鼓捣半天，就快完事时，根本不符合我的要求啊，这货
的关联关系得同时在todo和tag中记录各自相对应的id。如果新增一个todo，然后这个todo中
又新增了几个tag，还得先生成多个唯一的ID，然后再保存对应关系。如果再编辑一下这个todo，
把里面某个tag替换一下，被替换的tag又得手动解除关联关系。各种繁琐的操作。这很不符合我风格啊。

无奈啊，又得去研究一下其他的解决方式，发现一个`nosql`特有的特性——map/reduce，每条todo都自己
保存自己的tag，然后使用query查询出所有todo中的tag，然后reduce成一个数组，虽然性能有点差，
还是决定选择这种方式。

实现：

1. 首先tag需要有自动完成的要求，这个直接用`ant.design`组件`select`即可

```
const children = [];
this.props.dataSource.forEach((tag, idx) => {
    children.push(<Option key={tag}>{tag}</Option>);
});
// render() 中
<Select
    tags
    labelInValue
    value={this.state.tags}
    onChange={this.handleTagChange}>
    {children}
</Select>
```

2. 为了提高性能，只有打开页面的时候遍历所有todo查询出所有已经保存的tag。后续增加的tag
都先保存到顶层`state`中，以避免多次遍历操作，所以再保存todo的时候，需要判断哪些tag是新增的
哪些tag是已有的：

```
// tags 是该条todo的相关联的tag
parseTags (tags) {
    let total = tags.map(tag => (tag.label));
    let newTags = [];
    const dataSource = this.props.dataSource;
    for (let tag of total) {
        if (!dataSource.includes(tag)) {
            newTags.push(tag);
        }
    }
    return {total, newTags};
}
```

然后是保存新增的tag到顶层`state`中：

```
// 对应的action为
export const addTags = (tags) => ({type: types.ADD_TAGS, tags});

// 对应的reducer为
import { GET_TAGS, ADD_TAGS } from '../constants/ActionTypes';

const initialState = [];

export default function tags (state = initialState, action) {
    switch (action.type) {
        case GET_TAGS:
            return [...action.tags];
        case ADD_TAGS:
            return [...state, ...action.tags];
        default:
            return state;
    }
}
```

3. 在首次进入页面时，遍历所有的todo获取相关的tag：

```
// 查询数据
export const getTagsFromDb = () => {
    let todoMap = (doc) => {
        emit(doc.tags);
    };
    let todoReduce = (keys) => {
        let tags = [];
        for (let item of keys) {
            tags = tags.concat(item[0])
        }
        return Array.from(new Set(tags));
    };
    return db.query({
        map: todoMap,
        reduce: todoReduce
    }, {
        reduce: true
    }).then((result) => {
        return result.rows[0].value || [];
    }).catch((err) => {
        console.error(err);
    })
};

// 对应的action为
export const getTags = () => (dispatch, getState) => {
    if (getState().tags.length) {
        return getState().tags;
    }
    return getTagsFromDb().then(tags => {
        console.log('get tags success', tags);
        return dispatch({type: types.GET_TAGS, tags: tags});
    });
};

// 然后再组件首次渲染的时候获取
componentDidMount() {
    ...
    actions.getTags();
}
```